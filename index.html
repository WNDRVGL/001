<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Event Message (SNS style loop)</title>

  <!-- LINE Seed JP -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=LINE+Seed+JP:wght@400;700;800&display=swap" rel="stylesheet">

  <style>
    html, body{
      margin:0;
      height:100%;
      background:#000;
      overflow:hidden;
      font-family:"LINE Seed JP", system-ui, -apple-system, "Hiragino Kaku Gothic ProN","Noto Sans JP","Meiryo", sans-serif;
    }

    .stage{
      position:fixed;
      inset:0;
      background:#000;
      overflow:hidden;
    }

    .bubble{
      position:absolute;
      width:min(820px, 86vw);
      max-width: 86vw;
      padding: clamp(14px, 2.6vh, 28px) clamp(14px, 2.6vh, 34px);
      border-radius: 26px;
      background: rgba(255,255,255,.10);
      border: 1px solid rgba(255,255,255,.16);
      box-shadow:
        0 24px 70px rgba(0,0,0,.65),
        inset 0 1px 0 rgba(255,255,255,.10);
      backdrop-filter: blur(6px);
      -webkit-backdrop-filter: blur(6px);
      transform-origin: center;
    }

    .bubble:after{
      content:"";
      position:absolute;
      left: 46px;
      bottom: -18px;
      width: 0; height: 0;
      border-left: 18px solid transparent;
      border-right: 18px solid transparent;
      border-top: 18px solid rgba(255,255,255,.10);
      filter: drop-shadow(0 4px 0 rgba(255,255,255,.06));
    }

    .text{
      font-weight: 800;
      font-size: clamp(28px, 5.4vh, 80px);
      line-height: 1.12;
      letter-spacing: .02em;
      color: #fff;
      text-shadow: 0 3px 22px rgba(0,0,0,.65);
      word-break: break-word;
      white-space: pre-wrap;
    }

    .enter{
      opacity:0;
      transform: translateY(14px) scale(1.04);
      animation: enter .22s ease-out forwards;
    }
    @keyframes enter{
      to{ opacity:1; transform: translateY(0) scale(1); }
    }

    .flash{
      animation: flash .35s ease-out 1;
    }
    @keyframes flash{
      0%{ filter: brightness(1); }
      20%{ filter: brightness(1.9); }
      100%{ filter: brightness(1); }
    }

    .leave{
      animation: leave .28s ease-in forwards;
    }
    @keyframes leave{
      to{ opacity:0; transform: translateY(-10px) scale(.98); }
    }

    .status{
      position: fixed;
      left: 12px;
      bottom: 10px;
      font-size: 12px;
      color: rgba(255,255,255,0.45);
      user-select:none;
      font-weight: 700;
      letter-spacing: .2px;
      pointer-events:none;
    }
  </style>
</head>

<body>
  <div id="stage" class="stage" aria-label="メッセージ表示"></div>
  <div id="status" class="status">connecting…</div>

  <script>
    // Apps Script WebアプリURL(/exec)
    const SCRIPT_URL = "https://script.google.com/macros/s/AKfycbzLnD6M9UcMuxu-u4AzM_aOY_8yBR90NNPSYQp4rAVczef8jWkYiFrkxv3N2UQMivI2/exec";
    const TARGET_COL = "C";

    // 取得は10秒ごと（フォームはそのまま）
    const POLL_MS = 10000;

    // 表示間隔：1〜3秒ランダム
    const SHOW_INTERVAL_MIN_MS = 1000;
    const SHOW_INTERVAL_MAX_MS = 3000;

    // 画面に残す最大数（1〜10）
    const MAX_ON_SCREEN = 10;

    // 20字でカット
    const MAX_CHARS = 20;

    // 端の余白
    const MARGIN = 20;

    const stage = document.getElementById("stage");
    const statusEl = document.getElementById("status");

    // --- データ管理 ---
    // 全メッセージ（row順に保持）
    const all = [];        // [{row, text}]
    const indexByRow = new Map();

    // 次に表示する all のインデックス
    let playIndex = 0;

    // 画面上の吹き出し（古い順）
    const onScreen = [];   // [{el, idx}]

    // スケジューラ
    let nextTimer = null;

    let lastRowSeen = 1;

    function setStatus(t){ statusEl.textContent = t; }

    function fetchJSONP(url, params = {}) {
      return new Promise((resolve, reject) => {
        const cbName = "cb_" + Math.random().toString(36).slice(2);
        const script = document.createElement("script");
        const q = new URLSearchParams({ ...params, callback: cbName, t: String(Date.now()) });

        const cleanup = () => { try { delete window[cbName]; } catch {} script.remove(); };

        window[cbName] = (data) => { cleanup(); resolve(data); };
        script.onerror = () => { cleanup(); reject(new Error("JSONP load error")); };

        script.src = url + (url.includes("?") ? "&" : "?") + q.toString();
        document.body.appendChild(script);

        setTimeout(() => {
          if (window[cbName]) { cleanup(); reject(new Error("JSONP timeout")); }
        }, 8000);
      });
    }

    function trimToMaxChars(s){
      const arr = Array.from(String(s ?? ""));
      return arr.slice(0, MAX_CHARS).join("");
    }

    function randInt(min, max){
      return Math.floor(min + Math.random() * (max - min + 1));
    }

    function placeRandomly(el){
      const vw = window.innerWidth;
      const vh = window.innerHeight;

      el.style.left = "0px";
      el.style.top  = "0px";

      const r = el.getBoundingClientRect();
      const maxX = Math.max(MARGIN, vw - r.width  - MARGIN);
      const maxY = Math.max(MARGIN, vh - r.height - MARGIN);

      const x = Math.floor(MARGIN + Math.random() * (maxX - MARGIN));
      const y = Math.floor(MARGIN + Math.random() * (maxY - MARGIN));

      el.style.left = x + "px";
      el.style.top  = y + "px";
    }

    function createBubble(text){
      const b = document.createElement("div");
      b.className = "bubble enter flash";

      const t = document.createElement("div");
      t.className = "text";
      t.textContent = text;

      b.appendChild(t);
      stage.appendChild(b);

      placeRandomly(b);

      setTimeout(() => b.classList.remove("enter"), 260);
      setTimeout(() => b.classList.remove("flash"), 420);

      return b;
    }

    function removeOldest(){
      const oldest = onScreen.shift();
      if (!oldest || !oldest.el) return;

      oldest.el.classList.add("leave");
      setTimeout(() => {
        oldest.el.remove();
      }, 300);
    }

    // --- 仕様どおりの再生 ---
    // ・最初のメッセージから順に表示
    // ・10個目までは追加のみ
    // ・11個目以降は最古を消して追加
    // ・最後までいったら最初に戻って繰り返し
    function showNext(){
      if(all.length === 0){
        setStatus("waiting messages…");
        scheduleNext();
        return;
      }

      // 末尾までいったら最初へ
      if(playIndex >= all.length) playIndex = 0;

      // 表示する文言（#付与 + 20字カット）
      const msg = all[playIndex];
      const text = "#" + trimToMaxChars(msg.text);

      // 10枠埋まっているなら、最古を消してから追加
      if(onScreen.length >= MAX_ON_SCREEN){
        removeOldest();
      }

      const el = createBubble(text);
      onScreen.push({ el, idx: playIndex });

      playIndex += 1;

      setStatus(`ok | total=${all.length} | playIndex=${playIndex}/${all.length} | onScreen=${onScreen.length}`);
      scheduleNext();
    }

    function scheduleNext(){
      if(nextTimer) clearTimeout(nextTimer);
      const wait = randInt(SHOW_INTERVAL_MIN_MS, SHOW_INTERVAL_MAX_MS);
      nextTimer = setTimeout(showNext, wait);
    }

    // --- 取得 ---
    // 取得順（row順）を all に蓄積する
    function upsertMessages(msgs){
      let added = 0;

      // msgs は row 昇順で来る想定
      for(const m of msgs){
        if(!m || !m.text) continue;

        const row = Number(m.row);
        const text = String(m.text);

        if(!Number.isFinite(row)) continue;

        if(!indexByRow.has(row)){
          indexByRow.set(row, all.length);
          all.push({ row, text });
          added++;
        } else {
          // 同じ行が更新された場合は置換（任意）
          const idx = indexByRow.get(row);
          if(all[idx]) all[idx].text = text;
        }
      }

      return added;
    }

    async function poll(){
      try{
        const data = await fetchJSONP(SCRIPT_URL, {
          since: String(lastRowSeen),
          col: TARGET_COL
        });

        if(data && data.ok){
          const msgs = Array.isArray(data.messages) ? data.messages : [];
          const added = upsertMessages(msgs);

          const lr = Number(data.lastRow || lastRowSeen);
          if(Number.isFinite(lr)) lastRowSeen = Math.max(lastRowSeen, lr);

          // 取得できたら、スケジューラが止まっていた場合だけ再開
          if(!nextTimer) scheduleNext();

          setStatus(`ok | polled added=${added} | total=${all.length} | lastRow=${lastRowSeen} | onScreen=${onScreen.length}`);
        } else {
          setStatus("response not ok");
        }
      } catch (e){
        setStatus("error: " + e.message);
      }
    }

    function init(){
      poll();
      setInterval(poll, POLL_MS);

      // 再生開始
      scheduleNext();

      // リサイズ時：はみ出し対策で再配置
      window.addEventListener("resize", () => {
        onScreen.forEach(o => { if(o.el) placeRandomly(o.el); });
      });
    }

    init();
  </script>
</body>
</html>
