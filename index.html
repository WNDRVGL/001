<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Event Message Timeline</title>

  <!-- LINE Seed JP -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=LINE+Seed+JP:wght@400;700;800&display=swap" rel="stylesheet">

  <style>
    html, body{
      margin:0;
      height:100%;
      background:#000;
      overflow:hidden;
      font-family:"LINE Seed JP", system-ui, -apple-system, "Hiragino Kaku Gothic ProN","Noto Sans JP","Meiryo", sans-serif;
    }

    /* 黒一色 */
    .stage{
      position:fixed;
      inset:0;
      background:#000;
      overflow:hidden;
      padding: 22px 18px;
      box-sizing:border-box;
    }

    /* タイムライン（下に寄せる） */
    .timeline{
      position:absolute;
      left: 18px;
      right: 18px;
      bottom: 18px;
      display:flex;
      flex-direction:column;
      justify-content:flex-end;
      gap: 10px;
      pointer-events:none;
    }

    /* 吹き出し（横幅は画面に合わせる） */
    .bubble{
      width: min(980px, 100%);
      margin-left: 0;
      margin-right: auto;
      padding: 14px 18px;
      border-radius: 18px;
      background: rgba(255,255,255,.10);
      border: 1px solid rgba(255,255,255,.16);
      box-shadow:
        0 14px 44px rgba(0,0,0,.55),
        inset 0 1px 0 rgba(255,255,255,.08);
      backdrop-filter: blur(6px);
      -webkit-backdrop-filter: blur(6px);
      transform-origin: left bottom;
    }

    .text{
      color:#fff;
      font-weight: 800;
      font-size: clamp(20px, 3.3vh, 44px);
      line-height: 1.2;
      letter-spacing: .02em;
      text-shadow: 0 2px 16px rgba(0,0,0,.7);
      word-break: break-word;
      white-space: pre-wrap;
    }

    /* 新着：0.2秒でポップ */
    .pop{
      opacity: 0;
      transform: translateY(8px) scale(1.05);
      animation: popIn .20s ease-out forwards;
    }
    @keyframes popIn{
      to{ opacity:1; transform: translateY(0) scale(1); }
    }

    /* 1つ上に押し上げる時に気持ちよく */
    .push{
      animation: pushUp .18s ease-out;
    }
    @keyframes pushUp{
      from { transform: translateY(8px); }
      to   { transform: translateY(0); }
    }

    .status{
      position: fixed;
      left: 12px;
      bottom: 10px;
      font-size: 12px;
      color: rgba(255,255,255,0.55);
      user-select:none;
      font-weight: 800;
      letter-spacing: .2px;
      pointer-events:none;
      white-space: pre;
    }
  </style>
</head>

<body>
  <div class="stage">
    <div id="timeline" class="timeline" aria-label="タイムライン表示"></div>
  </div>
  <div id="status" class="status">booting…</div>

  <script>
    // Apps Script WebアプリURL(/exec)
    const SCRIPT_URL = "https://script.google.com/macros/s/AKfycbzLnD6M9UcMuxu-u4AzM_aOY_8yBR90NNPSYQp4rAVczef8jWkYiFrkxv3N2UQMivI2/exec";
    const TARGET_COL = "C";

    // 取得は10秒ごと
    const POLL_MS = 10000;

    // 表示間隔（タイムラインは一定の方が分かりやすいので 1秒固定）
    const STEP_MS = 1000;

    // 20字でカット
    const MAX_CHARS = 20;

    // 画面に表示できる最大行数（画面高さから自動でだいたい推定）
    function maxLines(){
      const vh = window.innerHeight;
      // 1行あたりの高さ（吹き出し+gap）を概算 76px〜
      const approxRow = 76;
      return Math.max(4, Math.floor((vh - 60) / approxRow));
    }

    const timeline = document.getElementById("timeline");
    const statusEl = document.getElementById("status");

    // 取得した全メッセージ（row順で保持）
    const all = [];
    const indexByRow = new Map();
    let playIndex = 0;
    let lastRowSeen = 1;

    let pollTimer = null;
    let stepTimer = null;

    function setStatus(lines){
      statusEl.textContent = Array.isArray(lines) ? lines.join("\n") : String(lines);
    }

    function fetchJSONP(url, params = {}) {
      return new Promise((resolve, reject) => {
        const cbName = "cb_" + Math.random().toString(36).slice(2);
        const script = document.createElement("script");

        const q = new URLSearchParams({
          ...params,
          callback: cbName,
          t: String(Date.now())
        });

        const cleanup = () => {
          try { delete window[cbName]; } catch {}
          script.remove();
        };

        const timeout = setTimeout(() => {
          if (window[cbName]) {
            cleanup();
            reject(new Error("JSONP timeout"));
          }
        }, 8000);

        window[cbName] = (data) => {
          clearTimeout(timeout);
          cleanup();
          resolve(data);
        };

        script.onerror = () => {
          clearTimeout(timeout);
          cleanup();
          reject(new Error("JSONP load error"));
        };

        script.src = url + (url.includes("?") ? "&" : "?") + q.toString();
        document.body.appendChild(script);
      });
    }

    function trimToMaxChars(s){
      const arr = Array.from(String(s ?? ""));
      return arr.slice(0, MAX_CHARS).join("");
    }

    function upsertMessages(msgs){
      let added = 0;
      for(const m of msgs){
        if(!m || !m.text) continue;
        const row = Number(m.row);
        if(!Number.isFinite(row)) continue;

        const text = String(m.text);

        if(!indexByRow.has(row)){
          indexByRow.set(row, all.length);
          all.push({ row, text });
          added++;
        } else {
          const idx = indexByRow.get(row);
          if(all[idx]) all[idx].text = text;
        }
      }
      return added;
    }

    async function poll(){
      try{
        const data = await fetchJSONP(SCRIPT_URL, {
          since: String(lastRowSeen),
          col: TARGET_COL
        });

        if(!data || data.ok !== true) throw new Error("response not ok");

        const msgs = Array.isArray(data.messages) ? data.messages : [];
        const added = upsertMessages(msgs);

        const lr = Number(data.lastRow || lastRowSeen);
        if(Number.isFinite(lr)) lastRowSeen = Math.max(lastRowSeen, lr);

        setStatus([
          `ok | polled added=${added} | total=${all.length}`,
          `playIndex=${playIndex}/${Math.max(1,all.length)} | lastRow=${lastRowSeen}`,
          `maxLines≈${maxLines()}`
        ]);
      } catch(e){
        setStatus([
          `error: ${e.message}`,
          `check: ?since=1&callback=cb_test&col=C`
        ]);
      }
    }

    function pushTimelineUpAnimation(){
      // 既存行に軽いpushアニメ
      [...timeline.children].forEach(el => {
        el.classList.remove("push");
        // reflow
        void el.offsetWidth;
        el.classList.add("push");
      });
    }

    function addLine(text){
      const bubble = document.createElement("div");
      bubble.className = "bubble pop";
      const t = document.createElement("div");
      t.className = "text";
      t.textContent = text;
      bubble.appendChild(t);

      // 追加＝最下部に入る（columnなので末尾が下）
      timeline.appendChild(bubble);

      // はみ出たら先頭（最上段）を削除
      const limit = maxLines();
      while(timeline.children.length > limit){
        timeline.removeChild(timeline.firstElementChild);
      }

      // アニメ整形
      setTimeout(() => bubble.classList.remove("pop"), 240);
    }

    function step(){
      if(all.length === 0) return;

      // 最終まで行ったら最初に戻す
      if(playIndex >= all.length) playIndex = 0;

      // 押し上げ → 最下部に新規
      pushTimelineUpAnimation();

      const msg = all[playIndex];
      const text = "#" + trimToMaxChars(msg.text);
      addLine(text);

      playIndex += 1;

      setStatus([
        `ok | total=${all.length} | playIndex=${playIndex}/${all.length}`,
        `onScreen=${timeline.children.length} | maxLines≈${maxLines()}`,
        `lastRow=${lastRowSeen}`
      ]);
    }

    function start(){
      // 取得
      poll();
      pollTimer = setInterval(poll, POLL_MS);

      // 表示
      stepTimer = setInterval(step, STEP_MS);

      // resizeで表示行数が変わるので調整
      window.addEventListener("resize", () => {
        const limit = maxLines();
        while(timeline.children.length > limit){
          timeline.removeChild(timeline.firstElementChild);
        }
      });
    }

    start();
  </script>
</body>
</html>
