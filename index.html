<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Event Message (SNS style)</title>

  <!-- LINE Seed JP -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=LINE+Seed+JP:wght@400;700;800&display=swap" rel="stylesheet">

  <style>
    html, body{
      margin:0;
      height:100%;
      background:#000;
      overflow:hidden;
      font-family:"LINE Seed JP", system-ui, -apple-system, "Hiragino Kaku Gothic ProN","Noto Sans JP","Meiryo", sans-serif;
    }

    .stage{
      position:fixed;
      inset:0;
      background:#000;
      overflow:hidden;
    }

    .bubble{
      position:absolute;
      width:min(820px, 86vw);
      max-width: 86vw;
      padding: clamp(14px, 2.6vh, 28px) clamp(14px, 2.6vh, 34px);
      border-radius: 26px;
      background: rgba(255,255,255,.10);
      border: 1px solid rgba(255,255,255,.16);
      box-shadow:
        0 24px 70px rgba(0,0,0,.65),
        inset 0 1px 0 rgba(255,255,255,.10);
      backdrop-filter: blur(6px);
      -webkit-backdrop-filter: blur(6px);
      transform-origin: center;
    }

    .bubble:after{
      content:"";
      position:absolute;
      left: 46px;
      bottom: -18px;
      width: 0; height: 0;
      border-left: 18px solid transparent;
      border-right: 18px solid transparent;
      border-top: 18px solid rgba(255,255,255,.10);
      filter: drop-shadow(0 4px 0 rgba(255,255,255,.06));
    }

    .text{
      font-weight: 800;
      font-size: clamp(28px, 5.4vh, 80px);
      line-height: 1.12;
      letter-spacing: .02em;
      color: #fff;
      text-shadow: 0 3px 22px rgba(0,0,0,.65);
      word-break: break-word;
      white-space: pre-wrap;
    }

    .enter{
      opacity:0;
      transform: translateY(14px) scale(1.04);
      animation: enter .22s ease-out forwards;
    }
    @keyframes enter{
      to{ opacity:1; transform: translateY(0) scale(1); }
    }

    .flash{
      animation: flash .35s ease-out 1;
    }
    @keyframes flash{
      0%{ filter: brightness(1); }
      20%{ filter: brightness(1.9); }
      100%{ filter: brightness(1); }
    }

    .leave{
      animation: leave .28s ease-in forwards;
    }
    @keyframes leave{
      to{ opacity:0; transform: translateY(-10px) scale(.98); }
    }

    .status{
      position: fixed;
      left: 12px;
      bottom: 10px;
      font-size: 12px;
      color: rgba(255,255,255,0.45);
      user-select:none;
      font-weight: 700;
      letter-spacing: .2px;
      pointer-events:none;
    }
  </style>
</head>

<body>
  <div id="stage" class="stage" aria-label="メッセージ表示"></div>
  <div id="status" class="status">connecting…</div>

  <script>
    // Apps Script WebアプリURL(/exec)
    const SCRIPT_URL = "https://script.google.com/macros/s/AKfycbzLnD6M9UcMuxu-u4AzM_aOY_8yBR90NNPSYQp4rAVczef8jWkYiFrkxv3N2UQMivI2/exec";
    const TARGET_COL = "C";

    // 10秒ごとに取得（読み込みはそのまま）
    const POLL_MS = 10000;

    // 画面に残す最大数（1〜10）
    const MAX_ON_SCREEN = 10;

    // 20字でカット
    const MAX_CHARS = 20;

    // 吹き出しが画面端に食い込まない余白（px）
    const MARGIN = 20;

    // ★表示間隔：1〜3秒をランダム
    const SHOW_INTERVAL_MIN_MS = 1000;
    const SHOW_INTERVAL_MAX_MS = 3000;

    const stage = document.getElementById("stage");
    const statusEl = document.getElementById("status");

    let lastRowSeen = 1;
    const seenKeys = new Set();

    // 表示待ち（取得順＝1から順）
    const queue = [];

    // 画面上の吹き出し（古い順＝1から順）
    const onScreen = [];

    // 表示スケジューラ
    let nextTimer = null;

    function setStatus(t){ statusEl.textContent = t; }

    function fetchJSONP(url, params = {}) {
      return new Promise((resolve, reject) => {
        const cbName = "cb_" + Math.random().toString(36).slice(2);
        const script = document.createElement("script");
        const q = new URLSearchParams({ ...params, callback: cbName, t: String(Date.now()) });

        const cleanup = () => { try { delete window[cbName]; } catch {} script.remove(); };

        window[cbName] = (data) => { cleanup(); resolve(data); };
        script.onerror = () => { cleanup(); reject(new Error("JSONP load error")); };

        script.src = url + (url.includes("?") ? "&" : "?") + q.toString();
        document.body.appendChild(script);

        setTimeout(() => {
          if (window[cbName]) { cleanup(); reject(new Error("JSONP timeout")); }
        }, 8000);
      });
    }

    function trimToMaxChars(s){
      const arr = Array.from(String(s ?? ""));
      return arr.slice(0, MAX_CHARS).join("");
    }

    function enqueueMessage(text, rowId){
      const clean = String(text || "").trim();
      if(!clean) return;

      const key = (rowId != null) ? `row:${rowId}` : `txt:${clean}`;
      if(seenKeys.has(key)) return;
      seenKeys.add(key);

      // 取得順に並べる＝1から順に表示される
      queue.push({ text: "#" + trimToMaxChars(clean), row: rowId });
    }

    function randInt(min, max){
      return Math.floor(min + Math.random() * (max - min + 1));
    }

    function placeRandomly(el){
      const vw = window.innerWidth;
      const vh = window.innerHeight;

      el.style.left = "0px";
      el.style.top  = "0px";

      const r = el.getBoundingClientRect();
      const maxX = Math.max(MARGIN, vw - r.width  - MARGIN);
      const maxY = Math.max(MARGIN, vh - r.height - MARGIN);

      const x = Math.floor(MARGIN + Math.random() * (maxX - MARGIN));
      const y = Math.floor(MARGIN + Math.random() * (maxY - MARGIN));

      el.style.left = x + "px";
      el.style.top  = y + "px";
    }

    function createBubble(msg){
      const b = document.createElement("div");
      b.className = "bubble enter flash";

      const t = document.createElement("div");
      t.className = "text";
      t.textContent = msg.text;

      b.appendChild(t);
      stage.appendChild(b);

      placeRandomly(b);

      setTimeout(() => b.classList.remove("enter"), 260);
      setTimeout(() => b.classList.remove("flash"), 420);

      return b;
    }

    function removeOldest(){
      const oldest = onScreen.shift();
      if (!oldest || !oldest.el) return;

      oldest.el.classList.add("leave");
      setTimeout(() => {
        oldest.el.remove();
      }, 300);
    }

    function stepShowNext(){
      // キューが空なら待つ（pollで増える）
      if(queue.length === 0){
        scheduleNext();
        setStatus(`ok | onScreen=${onScreen.length} | queue=0 | lastRow=${lastRowSeen}`);
        return;
      }

      // 10個までは消さずに追加
      if(onScreen.length < MAX_ON_SCREEN){
        const msg = queue.shift();
        const el = createBubble(msg);
        onScreen.push({ el, row: msg.row });
      } else {
        // 10個揃ったら「1から順に消して、11以降を順に表示」
        removeOldest();
        const msg = queue.shift();
        const el = createBubble(msg);
        onScreen.push({ el, row: msg.row });
      }

      setStatus(`ok | onScreen=${onScreen.length} | queue=${queue.length} | lastRow=${lastRowSeen}`);
      scheduleNext();
    }

    function scheduleNext(){
      if(nextTimer) clearTimeout(nextTimer);
      const wait = randInt(SHOW_INTERVAL_MIN_MS, SHOW_INTERVAL_MAX_MS);
      nextTimer = setTimeout(stepShowNext, wait);
    }

    async function poll(){
      try{
        const data = await fetchJSONP(SCRIPT_URL, {
          since: String(lastRowSeen),
          col: TARGET_COL
        });

        if(data && data.ok){
          const msgs = Array.isArray(data.messages) ? data.messages : [];
          msgs.forEach(m => {
            if(m && m.text) enqueueMessage(m.text, m.row);
          });

          const lr = Number(data.lastRow || lastRowSeen);
          if(Number.isFinite(lr)) lastRowSeen = Math.max(lastRowSeen, lr);

          // 表示スケジューラが止まっていたら再開
          if(!nextTimer) scheduleNext();
          setStatus(`ok | polled | onScreen=${onScreen.length} | queue=${queue.length} | lastRow=${lastRowSeen}`);
        } else {
          setStatus("response not ok");
        }
      } catch (e){
        setStatus("error: " + e.message);
      }
    }

    function init(){
      poll();
      setInterval(poll, POLL_MS);

      // 起動時：表示スケジューラ開始
      scheduleNext();

      // リサイズ時：はみ出し回避で位置を再抽選
      window.addEventListener("resize", () => {
        onScreen.forEach(o => { if(o.el) placeRandomly(o.el); });
      });
    }

    init();
  </script>
</body>
</html>
